<!DOCTYPE html>
<html>
  <head>
    <title>COVID-19 DASHBOARD</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v2.min.js"></script>
    <script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
    
    <!-- Load Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.4/dist/leaflet.css" integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.3.4/dist/leaflet.js" integrity="sha512-nMMmRyTVoLYqjP9hrbed9S+FzjZHW5gY1TWCHA5ckwXZBadntCNs8kEqAWdrb9O7rxbCaA4lKTIWjDXZxflOcA==" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js" charset="utf-8"></script>

    <style>
      .kmeans-chart {
        font-family: "Open Sans", Arial, Helvetica, sans-serif;
        font-size: 9px;
        fill: #ccc;
      }

      .kmeans-chart .centroid {
        stroke: #000;
        stroke-width: 2px;
      }

      .kmeans-chart text.label {
        font-size: 12px;
        fill: black;
      }

      .kmeans-chart .axis line, .axis path {
        fill: none;
        stroke-width: 1px;
        stroke: #ccc;
        shape-rendering: crispEdges;
      }
    
      #mapid { height: 500px; }
        .legend rect {
  stroke-width: 2px;
}

.tooltip {
  opacity: 0;
}

.arc path:hover {
  opacity: 0.7;
}

.bar {
        fill: steelblue;
      }
      .axis {
        font-size: 14px;
      }
      .tooltip {
        position: absolute;
        text-align: center;
        width: 80px;
        height: 40px;
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        pointer-events: none;
      }

    #chart path{
        border: 1px solid red;
        stroke: rgb(0, 0, 0);
        stroke-width: 1.5px;
      }
      path {
        stroke: black;
        stroke-width: 0.8px;
		margin-left:600px;
      }
	  
     #tooltip {
        position: absolute;
        z-index: 999;
        padding: 8px;
        background-color: white;
        border: 1px solid #000;
        font-size: 14px;
        font-weight: bold;
        pointer-events: none;
      }
	  
	  #chart3 path{
	  margin:500px;
}
.chart4 {
      margin:900px;
margin-top:2000px;	  
	}
    
    .tooltip {
            position: absolute;
            text-align: center;
            width: 80px;
            height: 40px;
            padding: 1px;
            font-size: 15px;
            font-weight: bold;
            background-color: #fff;
            border: 1px solid #ddd;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.9s;
        }

        .arc:hover .tooltip {
            opacity: 6;
        }
	  
	      #chart {
        width: 800px;
        height: 400px;
        margin: 50px;
      }
      .bar {
        fill: #2d9cdb;
      }
      .bar:hover {
        fill: #2251a3;
      }
	  
    
  .kmeans-chart {
    font-family: "Open Sans", Arial, Helvetica, sans-serif;
    font-size: 9px;
    fill: #ccc;
  }

  .kmeans-chart .centroid {
    stroke: #000;
    stroke-width: 2px;
  }

  .kmeans-chart text.label {
    font-size: 12px;
    fill: #333;
  }

  .kmeans-chart .axis line, .axis path {
    fill: none;
    stroke-width: 1px;
    stroke: #ccc;
    shape-rendering: crispEdges;
  }
body{
    background-color: navajowhite;
}
.legend rect {
      stroke-width: 2px;
    }

    .tooltip {
      opacity: 0;
    }

    .arc path:hover {
      opacity: 0.7;
    }

    .tooltip {
      position: absolute;
      z-index: 10;
      opacity: 0;
      background-color: #fff;
      padding: 8px;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      font-size: 14px;
    }
    .tooltip2 {
        position: absolute;
        background-color: white;
        border: 1px solid black;
        padding: 5px;
        font-size: 12px;
      }
	  
    </style>
  </head>



  <br>
  <h1>WORLD MAP</h1>
  <div id="tooltip"></div>
  <svg width="960" height="600"></svg>
  <br><br>
  <h1>US DATA WITH TOTAL CASES AND DATES</h1>
  <div class="chart0"></div>
  <div class="tooltip2"></div>
  <br><br>
  <h1>CONTINENTS VS TOTAL CASES</h1>
  <div id="chart"></div>
  <br><br>
  <h1>ANIMATED PIE CHART</h1>
  <div id="chart4"></div>
  <br><br>
  <h1>COMPARISON BETWEEN POVERTY AND TOTAL CASES</h1>
  <h3>Poverty Chart</h3>
  <div id="chart1"></div>
  <br><br>
  <h3>Total Cases Chart</h3>
  <div id = "chart10"></div>
  <br><br>
<div id="kmeans" class="kmeans-chart"></div>

  <h1>LEAFLET MAP</h1>
  <div id="mapid"></div>
  <br><br>
  <h1>BRUSHING</h1>
  <div id="chart8"></div>
  <div id="chart9"></div>
<div id="tooltip1" class="tooltip1"></div>
<div id="selectedValues"></div>
<br><br>
  
  <div id="chart5" ></div>
<div id="chart7"></div>

<br><br>
<!-- Load d3.js and the geo projection plugin -->
<script src="https://d3js.org/d3.v7.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script>
const svg = d3.select("svg");
const width = +svg.attr("width");
const height = +svg.attr("height");

const colorScale = d3.scaleSequential(d3.interpolateOranges).domain([0, 1]);

const projection = d3
  .geoMercator()
  .scale(130)
  .translate([width / 2, height / 1.4]);

const path = d3.geoPath().projection(projection);

d3.json(
  "https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson"
).then(function (data) {
  d3.csv(
    "https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv"
  ).then(function (covidData) {
    const latestData = d3.rollup(
      covidData.filter((d) => d.date === "2022-01-01"),
      (v) => ({ 
        total_cases_per_million: v[0].total_cases_per_million,
        total_vaccinations: v[0].total_vaccinations,
        total_deaths_per_million: v[0].total_deaths_per_million,
        extreme_poverty: v[0].extreme_poverty
      }),
      (d) => d.location
    );

    data.features.forEach((d) => {
      const locationData = latestData.get(d.properties.name);
      if (locationData) {
        d.value = locationData.total_cases_per_million ?? 0;
        d.vaccinations = locationData.total_vaccinations ?? 0;
        d.deaths = locationData.total_deaths_per_million ?? 0;
        d.extreme_poverty = locationData.extreme_poverty ?? 0;
      } else {
        d.value = 0;
        d.vaccinations = 0;
        d.deaths = 0;
        d.extreme_poverty = 0;
      }
    });

    svg
      .selectAll("path")
      .data(data.features)
      .enter()
      .append("path")
      .attr("d", path)
      .attr("fill", (d) => colorScale(d.value / 100000))
      .attr("title", (d) => `${d.properties.name}: ${d.value}`)
      .on("mouseover", function (event, d) {
        d3.select(this).style("opacity", 0.5);
        d3.select("#tooltip")
          .style("left", event.pageX + "px")
          .style("top", event.pageY - 28 + "px")
          .text(`${d.properties.name}: ${d.value} cases per million , ${d.vaccinations} vaccinations, ${d.deaths} deaths per million, ${d.extreme_poverty} poverty rate`);
      })
      .on("mouseout", function () {
        d3.select(this).style("opacity", 1);
        d3.select("#tooltip").text("");
      });

    // Define the color scale bar
    const defs = svg.append("defs");
    const gradient = defs
      .append("linearGradient")
      .attr("id", "gradient")
      .attr("x1", "0%")
      .attr("y1", "0%")
      .attr("x2", "100%")
      .attr("y2", "0%");

    // Define the colors and positions of the gradient stops
    gradient
      .append("stop")
      .attr("offset", "0%")
      .attr("stop-color", colorScale(1))
      .attr("stop-opacity", 1);

    gradient
      .append("stop")
      .attr("offset", "100%")
      .attr("stop-color", colorScale(0))
      .attr("stop-opacity", 1);
      // Add the color scale bar
const legend = svg.append("g").attr("id", "legend");

legend
  .append("rect")
  .attr("x", 20)
  .attr("y", height - 15)
  .attr("width", width - 40)
  .attr("height", 20)
  .style("fill", "url(#gradient)");

// Add the legend text
const minCases = d3.min(data.features, (d) => d.value);
const maxCases = d3.max(data.features, (d) => d.value);
legend
  .append("text")
  .attr("x", 25)
  .attr("y", height - 20)
  .style("text-anchor", "start")
  .style("font-size", "12px")
  .text("max cases");

legend
  .append("text")
  .attr("x", width - 25)
  .attr("y", height - 20)
  .style("text-anchor", "end")
  .style("font-size", "12px")
  .text("min cases");

// Add a tooltip element
d3.select("body")
  .append("div")
  .attr("id", "tooltip")
  .style("position", "absolute")
  .style("z-index", "10")
  .style("visibility", "hidden")
  .style("background", "white")
  .style("border-radius", "5px")
  .style("padding", "5px");
});
});


//total cases and continents
const svg2 = d3.select("#chart")
  .append("svg")
  .attr("width", 1000)
  .attr("height", 500);

const margin = { top: 50, right: 50, bottom: 50, left: 100 };

const width2 = 1000 - margin.left - margin.right;
const height2 = 500 - margin.top - margin.bottom;

const chart = svg2.append("g")
  .attr("transform", `translate(${margin.left}, ${margin.top})`);

let dataArray = [];

// Create x and y scales
const xScale = d3.scaleBand()
  .range([0, width2])
  .padding(0.2);

const yScale = d3.scaleLinear()
  .range([height2, 0]);

// Create x and y axes
const xAxis = d3.axisBottom(xScale);
const yAxis = d3.axisLeft(yScale);

chart.append("g")
  .attr("class", "x-axis")
  .attr("transform", `translate(0, ${height2})`)
  .call(xAxis);

chart.append("g")
  .attr("class", "y-axis")
  .call(yAxis);

d3.csv("https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv").then(function(data) {
  const groupedData = d3.rollup(
  data.filter(d => d.continent !== ""),
  v => d3.sum(v, d => d.total_cases),
  d => d.continent
);

const dataArray = Array.from(groupedData, ([continent, cases]) => ({ continent, cases }));

  updateAxes(dataArray);
});

function updateAxes(data) {
  xScale.domain(data.map(d => d.continent));
  yScale.domain([0, d3.max(data, d => d.cases)]);

  chart.select(".x-axis")
    .transition()
    .duration(500)
    .call(xAxis);

  chart.select(".y-axis")
    .transition()
    .duration(500)
    .call(yAxis);
  
  // Bind data to rect elements
  const bars = chart.selectAll(".bar")
    .data(data, d => d.continent);
  
  // Enter new bars
  bars.enter()
    .append("rect")
    .attr("class", "bar")
    .attr("x", d => xScale(d.continent))
    .attr("y", d => yScale(d.cases))
    .attr("width", xScale.bandwidth())
    .attr("height", d => height2 - yScale(d.cases))
    .attr("fill", "steelblue");
  
  // Update existing bars
  bars.transition()
    .duration(500)
    .attr("x", d => xScale(d.continent))
    .attr("y", d => yScale(d.cases))
    .attr("width", xScale.bandwidth())
    .attr("height", d => height2 - yScale(d.cases));
  

  bars.exit()
    .transition()
    .duration(500)
    .attr("height", 0)
    .remove();
}

   
    


// COVID-19 cases data animated pie chart
const data4 = [
{ country: "NIGER", cases: 282.5  },
{ country: "MADAGASACAR", cases: 1771 },
{ country: "CHINA", cases: 92.6 }
];

// Create a pie chart
const width4 = 500;
const height4 = 700;
const radius = Math.min(width4, height4) / 2;

const svg4 = d3.select("#chart4")
.append("svg")
.attr("width", width4)
.attr("height", height4)
.append("g")
.attr("transform", `translate(${width4 / 2}, ${height4 / 2})`);


const color = d3.scaleOrdinal()
.domain(data4.map(d => d.country))
.range(d3.schemeCategory10);

const pie = d3.pie()
.value(d => d.cases);

const arc = d3.arc()
.innerRadius(0)
.outerRadius(radius);

const arcs = svg4.selectAll("arc")
.data(pie(data4))
.enter()
.append("g")
.attr("class", "arc");

arcs.append("path")
.attr("d", arc)
.attr("fill", d => color(d.data.country))
.on("mouseover", function (d) {
d3.select(this)
.transition()
.duration(150)
.attr("transform", function (d) {
const centroid = arc.centroid(d);
const x = centroid[0];
const y = centroid[0];
const angle = Math.atan2(y, x) * 2 / Math.PI;
return `translate(${centroid[0]}, ${centroid[0]}) rotate(${angle})`;
});
d3.select(this).select(".tooltip").style("opacity", 1);
})
.on("mouseout", function (d) {
d3.select(this)
.transition()
.duration(500)
.attr("transform", "translate(0,0)");
d3.select(this).select(".tooltip").style("opacity", 0);
});

arcs.append("text")
.attr("transform", d =>  `translate(${arc.centroid(d)})`)
.attr("text-anchor", "middle")
.text(d => `${d.data.country}: ${d.data.cases}`);

arcs.append("foreignObject")
.attr("class", "tooltip")
.attr("x", 0)
.attr("y", 0)
            .attr("width", width)
.attr("height", height)

.html(d => `<p>${d.data.country}</p><p>${d.data.cases}</p>`);

// Set the dimensions of the canvas / graph
const margin5 = { top: 80, right: 100, bottom: 200, left: 70 };
const width5 = window.innerWidth - margin5.left - margin5.right - 20;
const height5 = 500 - margin5.top - margin5.bottom;

      
      // Add the SVG element
      const svg5 = d3.select("#chart5")
        .append("svg")
        .attr("width", width5 + margin5.left + margin5.right)
        .attr("height", height5 + margin5.top + margin5.bottom)
        .append("g")
        .attr("transform", "translate(" + margin5.left + "," + margin5.top + ")");
      
      // Load the data from the OWID COVID-19 dataset
      d3.csv("https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/latest/owid-covid-latest.csv").then(function(data) {
        
        // Filter the data to only include the selected countries
        const countries = ["United States", "India", "China", "Brazil", "Russia"];
const filteredData = data.filter(d => countries.includes(d.location))

        
        // Sort the data by total cases
        filteredData.sort((a, b) => d3.descending(+a.total_cases, +b.total_cases));
        
        // Define the color scale
        const color = d3.scaleOrdinal()
          .domain(countries)
          .range(["steelblue", "darkorange", "green", "red", "purple"]);
        
        // Scale the range of the data
        const x = d3.scaleBand()
          .range([0, width5])
          .domain(filteredData.map(d => d.location))
          .padding(0.1);
          const y1 = d3.scaleLinear()
  .range([height5, 0])
  .domain([0, d3.max(filteredData, d => +d.total_cases_per_million)*3.2]);

        const y2 = d3.scaleLinear()
          .range([height5, 0])
          .domain([0, d3.max(filteredData, d => +d.total_deaths_per_million)]);
          const y3 = d3.scaleLinear()
  .range([height5, 0])
  .domain([0, d3.max(filteredData, d => +d.hospital_beds_per_thousand) * 1.2]); 

  const y4 = d3.scaleLinear()
  .range([height5, 0])
  .domain([0, d3.max(filteredData, d => +d.stringency_index)]);


          
        // Add the x-axis
        svg5.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(" + (width5 + margin5.right) + ",0)")
          .call(d3.axisBottom(x))
          .selectAll("text")
          .style("text-anchor", "end")
          .attr("dx", "-.8em")
          .attr("dy", ".15em")
          .attr("transform", "rotate(-65)");
      
      // Add the y-axes
      svg5.append("g")
        .attr("class", "y axis")
        .call(d3.axisLeft(y1));
      svg5.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + width5 + ",0)")
        .call(d3.axisRight(y2));
      svg5.append("g")
        .attr("class", "y axis")
        .attr("transform", "translate(" + (width5 + margin5.right) + ",0)")
        .call(d3.axisRight(y3));
        svg5.append("g")
  .attr("class", "y axis")
  .attr("transform", "translate(" + (width5 + 2*margin5.right) + ",0)")
  .call(d3.axisRight(y4));

        
// Add the bars for total cases
svg5.selectAll(".bar")
  .data(filteredData)
  .enter().append("rect")
  .attr("class", "bar")
  .attr("x", d => x(d.location))
  .attr("width", x.bandwidth())
  .attr("y", d => y1(+d.total_cases_per_million))
  .attr("height", d => height5 - y1(+d.total_cases_per_million))
  .style("fill", d => color(d.location))
 
// Add the bars for total deaths
svg5.selectAll(".bar2")
  .data(filteredData)
  .enter().append("rect")
  .attr("class", "bar2")
  .attr("x", d => x(d.location) + x.bandwidth() / 4)
  .attr("width", x.bandwidth() / 4)
  .attr("y", d => y2(+d.total_deaths_per_million))
  .attr("height", d => height5 - y2(+d.total_deaths_per_million))
  .style("fill", d => color(d.location))

// Add the bars for hospital beds
svg5.selectAll(".bar3")
  .data(filteredData)
  .enter().append("rect")
  .attr("class", "bar3")
  .attr("x", d => x(d.location) + 2 * x.bandwidth() / 4)
  .attr("width", x.bandwidth() / 4)
  .attr("y", d => y3(+d.hospital_beds_per_thousand))
  .attr("height", d => height5 - y3(+d.hospital_beds_per_thousand))
  .style("fill", d => color(d.location))

svg5.selectAll(".bar4")
  .data(filteredData)
  .enter().append("rect")
  .attr("class", "bar4")
  .attr("x", d => x(d.location) + 3 * x.bandwidth() / 4)
  .attr("width", x.bandwidth() / 4)
  .attr("y", d => y4(+d.stringency_index))
  .attr("height", d => height5 - y4(+d.stringency_index))
  .style("fill", d => color(d.location));
 


 // Add the legend
const legend = svg5.append("g")
  .attr("font-family", "sans-serif")
  .attr("font-size", 12)
  .attr("text-anchor", "end")
  .attr("transform", `translate(0,${height5 + margin5.top + 20})`) // adjust the translate attribute
  .selectAll("g")
  .data(countries)
  .enter().append("g")
  .attr("transform", (d, i) => `translate(0,${i * 20})`);
legend.append("rect")
  .attr("x", width5 + margin5.right - 20)
  .attr("width", 15)
  .attr("height", 15)
  .attr("fill", color)
  .attr("stroke", color)
  .on("click", function(d) {
    // Toggle the visibility of the corresponding bars
    const active = !d3.select(this).classed("inactive");
    const newOpacity = active ? 0 : 1;
    d3.selectAll("." + d.toLowerCase())
      .transition()
      .duration(200)
      .style("opacity", newOpacity);
    d3.select(this).classed("inactive", !active);
  });
legend.append("text")
  .attr("x", width5 + margin5.right - 30)
  .attr("y", 9.5)
  .attr("dy", "0.32em")
  .text(d => d);

    
  // Add a tooltip element
  const tooltip = d3.select("body")
    .append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);
    
  // Add a title
  svg5.append("text")
    .attr("x", (width5 / 2))
    . attr("y", 0 - (margin5.top / 2))
    .attr("text-anchor", "middle")
    .style("font-size", "24px")
    .style("text-decoration", "underline")
    .text("COVID-19 Outbreak in Selected Countries");

    // Add text to explain Bar 1
svg5.append("text")
  .attr("x", x.bandwidth() / 2)
  .attr("y", height5 + margin5.top + 20)
  .attr("text-anchor", "middle")
  .text("bar 1 : Total Cases per Million");
  
// Add text to explain Bar 2
svg5.append("text")
  .attr("x", x.bandwidth() / 1 + x.bandwidth())
  .attr("y", height5 + margin5.top + 20)
  .attr("text-anchor", "middle")
  .text("bar 2 : Total Deaths per Million");
  
// Add text to explain Bar 3
svg5.append("text")
  .attr("x", x.bandwidth() / 2 + 3 * x.bandwidth())
  .attr("y", height5 + margin5.top + 20)
  .attr("text-anchor", "middle")
  .text("bar 3 : Hospital Beds per Thousand");
// Add text to explain Bar 4
svg5.append("text")
  .attr("x", x.bandwidth() / 5 + 5 * x.bandwidth())
  .attr("y", height5 + margin5.top + 20)
  .attr("text-anchor", "middle")
  .text("bar 4 : Stringency Index");

  

    
});

    const width6 = 400;
    const height6 = 650;
    const radius6 = Math.min(width6, height6) / 2;

    // Load the data from the OWID COVID-19 dataset
    d3.csv("https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/latest/owid-covid-latest.csv").then(function(data) {

      // Check if data is an array
      if (!Array.isArray(data)) {
        console.error("Data is not an array.");
        return;
      }

      // Filter the data to only include countries with available vaccination and booster data
      const filteredData = data.filter(d => d.total_vaccinations !== "" && d.people_fully_vaccinated_per_hundred !== "" && d.total_boosters !== "");

      // Calculate the total number of cases and deaths
      const totalPoverty = d3.sum(filteredData, d => +d.total_cases);
      const totalDeaths = d3.sum(filteredData, d => +d.total_deaths);

      // Calculate the total number of fully vaccinated people and booster jabs
      const totalFullyVaccinated = d3.sum(filteredData, d => +d.people_fully_vaccinated);
      const totalBoosters = d3.sum(filteredData, d => +d.total_boosters);

      // Calculate the percentage of cases and deaths prevented by vaccinations and booster jabs
      const casesPrevented = (1 - ( totalPoverty/totalFullyVaccinated )) * 100;
      const deathsPrevented = (1 - (totalDeaths/totalFullyVaccinated )) * 100; 
      const casesPreventedByBoosters = (totalPoverty/(totalFullyVaccinated - totalBoosters)) * 100;

      // Create the data for the doughnut chart
      const doughnutData = [
        {label: "Cases Prevented", value: casesPrevented},
        {label: "Deaths Prevented", value: deathsPrevented},
        {label: "Cases Prevented by Boosters", value: casesPreventedByBoosters}
      ];

      // Create the color scale
      const colorScale = d3.scaleOrdinal()
        .domain(doughnutData.map(d => d.label))
        .range(["green", "orange", "blue"]);

      // Create the arc generator
      const arc = d3.arc()
        .outerRadius(radius6 - 10)
        .innerRadius(radius6 / 2);

      // Create the pie generator
      const pie = d3.pie()
        .sort(null)

.value(d => d.value);
  // Create the SVG element
  const svg = d3.select("#chart7")
    .append("svg")
    .attr("width", width6)
    .attr("height", height6)
    .append("g")
    .attr("transform", "translate(" + width6 / 2 + "," + height6 / 2 + ")");

  // Create the arcs
  const arcs = svg.selectAll(".arc")
    .data(pie(doughnutData))
    .enter()
    .append("g")
    .attr("class", "arc");

  // Draw the arcs
  arcs.append("path")
    .attr("d", arc)
    .attr("fill", d => colorScale(d.data.label))
    .on("mouseover", function(d) {
      tooltip.transition()
        .duration(200)
        .style("opacity", .9);
      tooltip.html(d.data.label + ": " + d.data.value.toFixed(2) + "%")
        .style("left", (d3.event.pageX) + "px")
        .style("top", (d3.event.pageY - 28) + "px");
    })
    .on("mouseout", function(d) {
      tooltip.transition()
        .duration(500)
        .style("opacity", 0);
    });

  // Create the legend
  const legend = svg.selectAll(".legend")
    .data(doughnutData)
    .enter()
    .append("g")
    .attr("class", "legend")
    .attr("transform", function(d, i) {
      const height6 = 20;
      const x = -width6 / 5 + 10;
      const y = height6 * i - height6;
      return "translate(" + x + "," + y + ")";
    });

  // Draw the legend rectangles
  legend.append("rect")
    .attr("width", 16)
    .attr("height", 18)
    .style("fill", d => colorScale(d.label));

  // Draw the legend text
  legend.append("text")
    .attr("x", 26)
    .attr("y", 9)
    .attr("dy", ".35em")
    .text(d => d.label)
    .style("font-size", "12px");

    // Create the tooltip
const tooltip = d3.select("body")
  .append("div")
  .attr("class", "tooltip")
  .style("position", "absolute")
  .style("z-index", "10")
  .style("opacity", 0);

// Add mouseover and mouseout events to the arcs
arcs.on("mouseover", (event, d) => {
    tooltip.transition()
        .duration(200)
        .style("opacity", .9);
    tooltip.html(d.data.label + ": " + d.data.value.toFixed(2) + "%")
        .style("left", (event.pageX) + "px")
        .style("top", (event.pageY - 28) + "px");
})
.on("mouseout", () => {
    tooltip.transition()
        .duration(500)
        .style("opacity", 0);
});



  // Add the title to the chart
  svg.append("text")
    .attr("x", 0)
    .attr("y", -height6 / 2 + 20)
    .attr("text-anchor", "middle")
    .style("font-size", "16px")
    .style("font-weight", "bold")
    .text("Impact of Vaccinations and Booster Jabs on COVID-19");

  // Add the subtitle to the chart
  svg.append("text")
    .attr("x", 0)
    .attr("y", -height6 / 2 + 100)
    .attr("text-anchor", "middle")
    .style("font-size", "8px")
    .style("fill", "#666")
    .text("Percentage of Cases and Deaths Prevented by vaccinations");

  
}); 

//brushing

      // Set up the chart dimensions
      const margin8 = { top: 50, right: 50, bottom: 50, left: 50 };
      const width8 = 500 - margin8.left - margin8.right;
      const height8 = 200 - margin8.top - margin8.bottom;

      // Load the OWID data
      d3.csv("https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/latest/owid-covid-latest.csv").then(data => {
        // Filter out any rows with missing or invalid data in the 'total_cases_per_million' and 'gdp_per_capita' fields
        data = data.filter(d => !isNaN(d.total_cases_per_million) && !isNaN(d.gdp_per_capita));

        // Create the scales for the axes
        const xScale1 = d3.scaleLinear()
          .domain(d3.extent(data, d => d.total_cases_per_million))
          .range([0, width8]);

        const yScale1 = d3.scaleLinear()
          .domain(d3.extent(data, d => d.gdp_per_capita))
          .range([height8, 0]);

        const xScale2 = d3.scaleLinear()
          .domain(d3.extent(data, d => d.total_cases_per_million))
          .range([0, width8]);

        const yScale2 = d3.scaleLinear()
          .domain(d3.extent(data, d => d.total_deaths_per_million))
          .range([height8, 0]);

        // Create the axes
        const xAxis1 = d3.axisBottom(xScale1);
        const yAxis1 = d3.axisLeft(yScale1);

        const xAxis2 = d3.axisBottom(xScale2);
        const yAxis2 = d3.axisLeft(yScale2);

        // Create the SVG element for chart8
        const svg1 = d3.select("#chart8")
          .append("svg")
          .attr("width", width8 + margin8.left + margin8.right)
          .attr("height", height8 + margin8.top + margin8.bottom)
          .append("g")
          .attr("transform", `translate(${margin8.left}, ${margin8.top})`);

        // Create the dots for the scatter plot of chart8
        const dots1 = svg1.selectAll(".dot")
          .data(data)
          .enter()
          .append("circle")
          .attr("class", "dot")
          .attr("cx", d => xScale1(d.total_cases_per_million))
          .attr("cy", d => yScale1(d.gdp_per_capita))
          .attr("r", 3)
          .style("fill", "steelblue");

        // Create the brush for chart8
        const brush1 = d3.brush()
          .extent([[0, 0], [width8, height8]])
          .on("brush", brushed1);

        svg1.append("g")
          .attr("class", "brush")
.call(brush1);
svg1.append("g")
  .attr("class", "x-axis")
  .attr("transform", `translate(0, ${height8})`)
  .call(xAxis1);

svg1.append("g")
  .attr("class", "y-axis")
  .call(yAxis1);



    const svg2 = d3.select("#chart9")
      .append("svg")
      .attr("width", width8 + margin8.left + margin8.right)
      .attr("height", height8 + margin8.top + margin8.bottom)
      .append("g")
      .attr("transform", `translate(${margin8.left}, ${margin8.top})`);

    
    const dots2 = svg2.selectAll(".dot")
      .data(data)
      .enter()
      .append("circle")
      .attr("class", "dot")
      .attr("cx", d => xScale2(d.total_cases_per_million))
      .attr("cy", d => yScale2(d.total_deaths_per_million))
      .attr("r", 3)
      .style("fill", "steelblue");

   
    const brush2 = d3.brush()
      .extent([[0, 0], [width8, height8]])
      .on("brush", brushed2);

    svg2.append("g")
      .attr("class", "brush")
      .call(brush2);
      svg2.append("g")
  .attr("class", "x-axis")
  .attr("transform", `translate(0, ${height8})`)
  .call(xAxis2);

svg2.append("g")
  .attr("class", "y-axis")
  .call(yAxis2);


  function brushed1(event) {
  if (event.selection) {
    const [x0, y0] = event.selection[0];
    const [x1, y1] = event.selection[1];

    // Get the data that falls within the selection
    const selectedData = data.filter(d =>
      x0 <= xScale1(d.total_cases_per_million) && xScale1(d.total_cases_per_million) <= x1 &&
      y0 <= yScale1(d.gdp_per_capita) && yScale1(d.gdp_per_capita) <= y1
    );

    // Highlight the selected dots on chart8
    dots1.style("fill", d => selectedData.includes(d) ? "red" : "steelblue");

    // Highlight the associated dots on chart9
    dots2.style("fill", d => selectedData.some(dataPoint => dataPoint.iso_code === d.iso_code) ? "red" : "steelblue");

    // Update the selected values element
    updateSelectedValues(selectedData);
  }
}

function brushed2(event) {
  if (event.selection) {
    const [x0, y0] = event.selection[0];
    const [x1, y1] = event.selection[1];

    // Get the data that falls within the selection
    const selectedData = data.filter(d =>
      x0 <= xScale2(d.total_cases_per_million) && xScale2(d.total_cases_per_million) <= x1 &&
      y0 <= yScale2(d.total_deaths_per_million) && yScale2(d.total_deaths_per_million) <= y1
    );

    // Highlight the selected dots on chart9
    dots2.style("fill", d => selectedData.includes(d) ? "red" : "steelblue");

    // Highlight the associated dots on chart8
    dots1.style("fill", d => selectedData.some(dataPoint => dataPoint.iso_code === d.iso_code) ? "red" : "steelblue");

    // Update the selected values element
    updateSelectedValues(selectedData);
  }
}

function updateSelectedValues(selectedData) {
  const selectedValues = d3.select("#selectedValues");
  selectedValues.html(selectedData.map(d => `${d.location}: ${d.total_cases_per_million} cases per million, ${d.total_deaths_per_million} deaths per million, ${d.gdp_per_capita} per capita`).join("<br>"));
}





var map = L
      .map('mapid')
      .setView([30, 100], 4);  
    
  
    L.tileLayer(
        'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a>',
        maxZoom: 6, // max zoom 
        }).addTo(map);
    
    // Add a svg layer to the map
    L.svg().addTo(map);
    
    // Create data for circles
    var markers = [
      {long: 69.345116, lat: 30.375321, population: 225199929, cases: 1510221}, // pak
      {long: 78.96288, lat: 20.593684, population: 1393409033, cases: 42931045}, // india
      {long: 104.195397, lat: 35.86166, population:1444216102, cases: 109526 } // china
    ];
  // circle for population
    d3.select("#mapid")
      .select("svg")
      .selectAll("myCircles")
      .data(markers)
      .enter()
      .append("circle")
        .attr("cx", function(d){ return map.latLngToLayerPoint([d.lat, d.long]).x })
        .attr("cy", function(d){ return map.latLngToLayerPoint([d.lat, d.long]).y })
        .attr("r", function(d){ return d.population/10000000})
        .style("fill", "blue")
        .attr("stroke", "blue")
        .attr("stroke-width", 2)
        .attr("fill-opacity", .10) 
      // circle for cases
      d3.select("#mapid")
      .select("svg")
      .selectAll("myCircles")
      .data(markers)
      .enter()
      .append("circle")
        .attr("cx", function(d){ return map.latLngToLayerPoint([d.lat, d.long]).x })
        .attr("cy", function(d){ return map.latLngToLayerPoint([d.lat, d.long]).y })
        .attr("r", function(d){ return d.cases/1000000})
        .style("fill", "orange")
        .attr("stroke", "orange")
        .attr("stroke-width", 3)
        .attr("fill-opacity", .4)
        // infor circle 
      d3.select("svg")
      .append("circle")
      .attr("class", "c")
        .attr("cx", 20)
        .attr("cy", 400)
        .attr("r", 15)
        .style("fill", "orange")
        .attr("stroke", "orange")
        .attr("stroke-width", 3)
        .attr("fill-opacity", .4)
      d3.select("svg") // info text
      .append("text")
      .attr("class", "c")
      .attr("transform", "translate(100,0)")
      .attr("x", -50)
      .attr("y", 410)
      .attr("font-size", "20px")
      .text("Total cases")
        // infor circle 
        d3.select("svg")
      .append("circle")
      .attr("class", "c")
        .attr("cx", 20)
        .attr("cy", 450)
        .attr("r", 15)
        .style("fill", "blue")
        .attr("stroke", "blue")
        .attr("stroke-width", 3)
        .attr("fill-opacity", .4)
      d3.select("svg") // info text
      .append("text")
      .attr("class", "c")
      .attr("transform", "translate(100,0)")
      .attr("x", -50)
      .attr("y", 460)
      .attr("font-size", "20px")
      .text("Total population")
      .on("mouseover", mouseover)
      .on("mousemove", mousemove)
      .on("mouseleave", mouseleave)
            // create a tooltip
            Tooltip = d3.select("svg")
      .append("div")
      .attr("class", "tooltip")
      .style("opacity", 1)
      .style("background-color", "white")
      .style("border", "solid")
      .style("border-width", "2px")
      .style("border-radius", "5px")
      .style("padding", "5px")
   
     var mouseover = function(d) {
      Tooltip.style("opacity", 1)
    }
    var mousemove = function(d) {
      Tooltip
        .html("long: " + d.long + "<br>" + "lat: " + d.lat)
        .style("left", (d3.mouse(this)[0]+10) + "px")
        .style("top", (d3.mouse(this)[1]) + "px")
    }
    var mouseleave = function(d) {
      Tooltip.style("opacity", 0)
    }
    // Function that update all the circle position if something change
    function update() {
      d3.selectAll("circle")
        .attr("cx", function(d){ return map.latLngToLayerPoint([d.lat, d.long]).x })
        .attr("cy", function(d){ return map.latLngToLayerPoint([d.lat, d.long]).y })
      d3.selectAll("c") // info text
      .attr("transform", "translate(140,0)")
      .attr("x", -50)
      .attr("y", 460)
      }
    
 // scatter
 const margin0 = { top: 50, right: 50, bottom: 50, left: 50 };
      const width0 = 800 - margin0.left - margin0.right;
      const height0 = 600 - margin0.top - margin0.bottom;

      const svg0 = d3
        .select(".chart0")
        .append("svg")
        .attr("width", width0 + margin0.left + margin0.right)
        .attr("height", height0 + margin0.top + margin0.bottom)
        .append("g")
        .attr("transform", `translate(${margin0.left}, ${margin0.top})`);

      // Load the data
      d3.csv(
        "https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv"
      ).then((data) => {
        // Select the columns we need and filter for United States and India
        data = data
          .filter((d) => d.location === "United States")
          .map((d) => ({
            date: new Date(d.date),
            total_cases_per_million: +d.total_cases_per_million,
            location: d.location,
          }));

        // Set up the scales
        const xScale = d3
          .scaleTime()
          .domain(d3.extent(data, (d) => d.date))
          .range([0, width0]);

        const yScale = d3
          .scaleLinear()
          .domain(d3.extent(data, (d) => d.total_cases_per_million))
          .range([height0, 0]);

        // Set up the axes
        const xAxis = d3.axisBottom(xScale).tickFormat(d3.timeFormat("%Y-%m-%d"));
        const yAxis = d3.axisLeft(yScale);

        svg0
          .append("g")
          .attr("transform", `translate(0, ${height0})`)
          .call(xAxis);

        svg0.append("g").call(yAxis);

        // Plot the data
        const tooltip = d3.select(".tooltip2");

        svg0
          .selectAll(".dot")
          .data(data)
          .join("circle")
          .attr("class", "dot")
          .attr("cx", (d) => xScale(d.date))
          .attr("cy", (d) => yScale(d.total_cases_per_million))
          .attr("r", 3)
          .style("fill", (d) => (d.location === "United States" ? "blue" : "red"))
          .on("mouseover", (event, d) => {
            tooltip
              .style("visibility", "visible")
              .html(`Date: ${d.date.toDateString()}<br>Location: ${d.location}<br>Total Cases per Million: ${d.total_cases_per_million.toFixed(2)}`);
})
.on("mousemove", (event) => {
tooltip
.style("top", event.pageY - 10 + "px")
.style("left", event.pageX + 10 + "px");
})
.on("mouseout", () => {
tooltip.style("visibility", "hidden");
});
});






 

                // Load the data
      d3.csv("https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv").then(function (data) {
        // Filter the data to include only the data for the desired countries
        var countries = ["Greece", "India", "Brazil", "Mexico"];
        var filteredData = data.filter(function (d) {
          return countries.includes(d.location);
        });

        // Aggregate the total cases by country
        var totalPovertyByCountry = d3.rollup(
          filteredData,
          function (v) {
            return d3.sum(v, function (d) {
              return d.extreme_poverty;
            });
          },
          function (d) {
            return d.location;
          }
        );

        // Convert the total cases by country to an array
        var totalPovertyArray = Array.from(totalPovertyByCountry, function (d) {
          return { country: d[0], totalPoverty: d[1] };
        });

        // Sort the array by total cases in descending order
        totalPovertyArray.sort(function (a, b) {
          return b.totalPoverty - a.totalPoverty;
        });

        // Set the dimensions and margins of the chart
        var margin = { top: 20, right: 20, bottom: 20, left: 20 },
          width = 500 - margin.left - margin.right,
          height = 500 - margin.top - margin.bottom;

        // Set the radius of the circular bar plot
        var radius = Math.min(width, height) / 2;

        // Set the color scale
        var color = d3
          .scaleOrdinal()
          .domain(totalPovertyArray.map(function (d) {
            return d.country;
          }))
          .range(d3.schemeCategory10);

        // Create the SVG container
        var svg = d3
          .select("#chart1")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr(
            "transform",
            "translate(" + width / 2 + "," + height / 2 + ")"
          );

        // Compute the angles and positions of the bars
        var pie = d3.pie().value(function (d) {
          return d.totalPoverty;
        });
        var data_ready = pie(totalPovertyArray);

        // Define the arc generator
        var arc = d3.arc().innerRadius(radius * 0.5).outerRadius(radius);

        // Draw the bars
        svg
          .selectAll("mySlices")
          .data(data_ready)
          .enter()
          .append("path")
          .attr("d", arc)
          .text("poverty")
          .attr("fill", function (d) {
            return color(d.data.country);
          })
          .attr("stroke", "white")
          .style("stroke-width", "2px")
          .style("opacity", 0.7);

        // Add labels
        svg
          .selectAll("mySlices")
          .data(data_ready)
          .enter()
          .append("text")
          .text(function (d) {
            return d.data.country;
  })
  .attr("transform", function (d) {
    return "translate(" + arc.centroid(d) + ")";
  })
  .style("text-anchor", "middle")
  .style("font-size", "12px");
});

        })
      


               // Load the data
               d3.csv("https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv").then(function (data) {
        // Filter the data to include only the data for the desired countries
        var countries = ["Greece", "India", "Brazil",  "Mexico"];
        var filteredData = data.filter(function (d) {
          return countries.includes(d.location);
        });

        // Aggregate the total cases by country
        var totalCasesByCountry = d3.rollup(
          filteredData,
          function (v) {
            return d3.sum(v, function (d) {
              return d.total_cases;
            });
          },
          function (d) {
            return d.location;
          }
        );

        // Convert the total cases by country to an array
        var totalCasesArray = Array.from(totalCasesByCountry, function (d) {
          return { country: d[0], totalCases: d[1] };
        });

        // Sort the array by total cases in descending order
        totalCasesArray.sort(function (a, b) {
          return b.totalCases - a.totalCases;
        });

        // Set the dimensions and margins of the chart
        var margin = { top: 20, right: 20, bottom: 20, left: 20 },
          width = 500 - margin.left - margin.right,
          height = 500 - margin.top - margin.bottom;

        // Set the radius of the circular bar plot
        var radius = Math.min(width, height) / 2;

        // Set the color scale
        var color = d3
          .scaleOrdinal()
          .domain(totalCasesArray.map(function (d) {
            return d.country;
          }))
          .range(d3.schemeCategory10);

        // Create the SVG container
        var svg = d3
          .select("#chart10")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
          .append("g")
          .attr(
            "transform",
            "translate(" + width / 2 + "," + height / 2 + ")"
          );

        // Compute the angles and positions of the bars
        var pie = d3.pie().value(function (d) {
          return d.totalCases;
        });
        var data_ready = pie(totalCasesArray);

        // Define the arc generator
        var arc = d3.arc().innerRadius(radius * 0.5).outerRadius(radius);

        // Draw the bars
        svg
          .selectAll("mySlices")
          .data(data_ready)
          .enter()
          .append("path")
          .attr("d", arc)
          .attr("fill", function (d) {
            return color(d.data.country);
          })
          .attr("stroke", "white")
          .style("stroke-width", "2px")
          .style("opacity", 0.7);

        // Add labels
        svg
          .selectAll("mySlices")
          .data(data_ready)
          .enter()
          .append("text")
          .text(function (d) {
            return d.data.country;
  })
  .attr("transform", function (d) {
    return "translate(" + arc.centroid(d) + ")";
  })
  .style("text-anchor", "middle")
  .style("font-size", "12px");
});

             

</script>



<script type="text/javascript">
  d3.csv("https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv", function(error, data) {
    if (error) throw error;
  
    var points = data.map(function(d) {
      return {
        x: d.population_density,
        y: d.median_age,
        fill: null,
        name: d.location
      };
    });
  
    kMeans("#kmeans", 1000, 600, points, 10, 10);
  });
  
  function kMeans(elt, w, h, points, numClusters, maxIter) {
    // the current iteration
    var iter = 1,
        centroids = [];
  
    var margin11 = {top: 30, right: 20, bottom: 20, left: 200},
        width11 = w - margin11.left - margin11.right,
        height11 = h - margin11.top - margin11.bottom;
  
    var colors = d3.scale.category20().range();
  
    var svg = d3.select(elt).append("svg")
        .style("width", width11 + margin11.left + margin11.right)
        .style("height", height11 + margin11.top + margin11.bottom);
        
    var group = svg.append("g")
        .attr("transform", "translate(" + margin11.left + "," + margin11.top + ")");
    
    svg.append("g")
        .append("text")
        .attr("class", "label")
        .attr("transform", "translate(" + (width11/2) + ", 20)")
        .text("K-means Clustering");
  
    // Randomly initialize centroids
    for (var i = 0; i < numClusters; i++) {
      centroids.push({
        x: Math.random() * width11,
        y: Math.random() * height11,
        fill: colors[i % colors.length]
      });
    }
  
    var xScale = d3.scale.linear()
      .range([0, width11])
      .domain([0, d3.max(points, function(d) { return d.x; })]);
  
    var yScale = d3.scale.linear()
      .range([height11, 0])
      .domain([0, d3.max(points, function(d) { return d.y; })]);
  
    var xAxis = d3.svg.axis()
  .scale(xScale)
  .orient("bottom");
  
  var yAxis = d3.svg.axis()
  .scale(yScale)
  .orient("left");
  
  group.append("g")
  .attr("class", "axis x-axis")
  .attr("transform", "translate(0," + height11 + ")")
  .call(xAxis);
  
  group.append("g")
  .attr("class", "axis y-axis")
  .call(yAxis);
  
  var pointGroup = group.append("g")
  .attr("class", "points");
  
  var centroidGroup = group.append("g")
  .attr("class", "centroids");
  
  var centroidsMoved = true;
  
  while (iter <= maxIter && centroidsMoved) {
  centroidsMoved = false;
  // assign each point to its nearest centroid
  points.forEach(function(point) {
  var distances = centroids.map(function(centroid) {
  return Math.sqrt(Math.pow(point.x - centroid.x, 2) + Math.pow(point.y - centroid.y, 2));
  });
  var closestCentroidIndex = distances.indexOf(d3.min(distances));
  if (point.fill !== centroids[closestCentroidIndex].fill) {
  point.fill = centroids[closestCentroidIndex].fill;
  centroidsMoved = true;
  }
  });
  // recalculate centroids
  centroids.forEach(function(centroid, i) {
    var pointsInCluster = points.filter(function(point) {
      return point.fill === centroid.fill;
    });
    if (pointsInCluster.length > 0) {
      var sumX = d3.sum(pointsInCluster, function(point) { return point.x; });
      var sumY = d3.sum(pointsInCluster, function(point) { return point.y; });
      var avgX = sumX / pointsInCluster.length;
      var avgY = sumY / pointsInCluster.length;
      if (centroid.x !== avgX || centroid.y !== avgY) {
        centroid.x = avgX;
        centroid.y = avgY;
        centroidsMoved = true;
      }
    }
  });
  
  // update visualization
  pointGroup.selectAll("circle")
    .data(points)
    .enter()
    .append("circle")
    .attr("cx", function(d) { return xScale(d.x); })
    .attr("cy", function(d) { return yScale(d.y); })
    .attr("r", 3)
    .style("fill", function(d) { return d.fill; })
    .on("mouseover", function(d) {
      d3.select(this).style("stroke", "#000").style("stroke-width", "2px");
      var xPosition = parseFloat(d3.select(this).attr("cx"));
      var yPosition = parseFloat(d3.select(this).attr("cy"));
      group.append("text")
        .attr("id", "tooltip")
        .attr("x", xPosition)
        .attr("y", yPosition - 15)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("font-size", "11px")
        .attr("font-weight", "bold")
        .attr("fill", "#000")
        .text(d.name);
    })
    .on("mouseout", function() {
      d3.select(this).style("stroke", "none");
      d3.select("#tooltip").remove();
    });
  
  centroidGroup.selectAll("circle")
    .data(centroids)
    .enter()
    .append("circle")
    .attr("class", "centroid")
    .attr("cx", function(d) { return xScale(d.x); })
    .attr("cy", function(d) { return yScale(d.y); })
    .attr("r", 5)
    .style("stroke", function(d) { return d.fill; })
    .style("fill", "#fff");
  
  centroidGroup.selectAll("circle")
    .data(centroids)
    .transition()
    .attr("cx", function(d) { return xScale(d.x); })
    .attr("cy", function(d) { return yScale(d.y); });
  
  iter++;
  }}
  </script>



<button onclick="update(datagdp1)">Continent Group 01 (GDP During 2020)</button>
<button onclick="update(datagdp2)">Continent Group 02 (GDP During 2023)</button>
<div id="my_dataviz1"></div>


<script>
	
// create 2 data_set
const datagdp1 = [
   {group: "South America", value: 3995023928},
   {group: "Africa", value:4083864572},
   {group: "Oceania", value: 3944459006}
];

const datagdp2 = [
   {group: "South America", value: 3987517678},
   {group: "Africa", value: 4070882987},
   {group: "Oceania", value:3896640237}
];

// set the dimensions and margins of the graph
const margin_gdp = {top: 30, right: 120, bottom: 70, left: 100},
    width7 = 460 - margin_gdp.left - margin_gdp.right,
    height7 = 400 - margin_gdp.top - margin_gdp.bottom;

// append the svg object to the body of the page
const svg_gdp = d3.select("#my_dataviz1")
  .append("svg")
    .attr("width", width7 + margin_gdp.left + margin_gdp.right)
    .attr("height", height7 + margin_gdp.top + margin_gdp.bottom)
  .append("g")
    .attr("transform", `translate(${margin_gdp.left},${margin_gdp.top})`);

// X axis
const x_gdp = d3.scaleBand()
  .range([ 0, width7 ])
  .domain(datagdp1.map(d => d.group))
  .padding(0.2);
svg_gdp.append("g")
  .attr("transform", `translate(0,${height7})`)
  .call(d3.axisBottom(x_gdp))

// Add Y axis
const y_gdp = d3.scaleLinear()
  .domain([3000000000,5000000000])
  .range([ height7, 0]);
svg_gdp.append("g")
  .attr("class", "myYaxis")
  .call(d3.axisLeft(y_gdp));

// A function that create / update the plot for a given variable:
function update(data) {

  var u = svg_gdp.selectAll("rect")
    .data(data)

    .join("rect")
    .transition()
    .duration(1000)
      .attr("x", d => x_gdp(d.group))
      .attr("y", d => y_gdp(d.value))
      .attr("width", x_gdp.bandwidth())
      .attr("height", d => height7 - y_gdp(d.value))
      .attr("fill", "#69b3a2")
}
    
// Initialize the plot with the first dataset
update(datagdp1)
</script>
</body>
</html>
  

